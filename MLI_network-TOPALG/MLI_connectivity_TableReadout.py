# -*- coding=utf-8 -*-
from __future__ import print_function

def goToLennon_MLI_connectivity_dir():
    from os import chdir
    chdir('/Users/maximebeau/Desktop/Science/4_Stage_UCL_WIBR_HAUSSER/My_project/Lennon_MLI_connectivity')

def write_synapses_table(SynapseGroup, targetFile): # SynapseGroup has to be S_MLI_MLI
    '''
    the SynapseGroup is a "Synapses" object from BRIAN
    linking two groups of neurons from which we want to read the connectivity 
    as a table of each source neuron index preceeding its target neurons indexes
    written in a "targetFile".
    '''

    
    trg=open(targetFile, 'w')
    
    i=0
    while i<=(len(SynapseGroup.source)-1): # there are 160 MLIs...
        trg.write(str(i)+" ") # write the i index, anyway
        j=0
        while j<=(len(SynapseGroup.target)-1): # ... potentially connected to the same t160 MLI that you screen
            if SynapseGroup.w[i,j].tolist()!=[] and SynapseGroup.w[i,j].tolist()!=[0.0]: # SynapseGroup has to be S_MLI_MLI
                trg.write(str(j)+" ")  # if there is a synapse, write after it the j index
            j+=1
        trg.write('\n') # go to next line after having screened the MLI i
        i+=1 # to screen the MLI i+1
    return



def tableTest(SynapseGroup):
    '''
    This function allows us to check some randomly chosen data of the table generated by the function write_synapses_table(),
    in order to confirm that we can exploit peacefully its data.
    '''
    from random import randint
    while 1:
        i=randint(0, 159)
        j=randint(0, 159)
        if SynapseGroup.w[i,j].tolist()!=[] and SynapseGroup.w[i,j].tolist()!=[ 0.]:
            print(SynapseGroup.w[i,j].tolist())
            diff = abs(j-i)
            if diff > 80:
                print('two '+str(diff)+' index units away neurons synapse detected')
                break



def translateTheMLItable(sourceFile, targetFile):
    '''
    pass from a file containing raw data :
    MLIindex1 MLIindex2 MLIindex3 MLIindex4 MLIindex5...
    to :
    The MLI number MLIindex1 diverges to the MLIs number MLIindex2, MLIindex3, MLIindex4... and MLIindex5.
    '''
    
    
    src=open(sourceFile, 'r')
    trg=open(targetFile, 'w')
    
    while 1:
        line = src.readline() # line = string composed of a new line
        if line == "":
            break
        lineParts = line.split() # create a list whose elements are the MLIindexes
        N=len(lineParts)
        
        # create a chain phrase in function of the number of targets N
        if N==1:
            ch="The MLI number {0} doesn't diverge to any neuron."
        elif N==2:
            ch="The MLI number {0} diverges to the MLI number {1}."
        elif N>=3:
            ch = "The MLI number {0} diverges to the MLIs number {1}"
            i=2
            while 1:
                if i==N-1:
                    partCh=" and number {"+str(i)+"}."
                    ch=ch+partCh
                    break
                partCh=", number {"+str(i)+"}"
                ch=ch+partCh
                i=i+1

        # formatting the chain
        if N==1:
            trg.write(ch.format(lineParts[0]))
        elif N==2:
            trg.write(ch.format(lineParts[0], lineParts[1]))
        elif N==3:
            trg.write(ch.format(lineParts[0], lineParts[1], lineParts[2]))
        elif N==4:
            trg.write(ch.format(lineParts[0], lineParts[1], lineParts[2], lineParts[3]))
        elif N==5:
            trg.write(ch.format(lineParts[0], lineParts[1], lineParts[2], lineParts[3], lineParts[4]))
        elif N==6:
            trg.write(ch.format(lineParts[0], lineParts[1], lineParts[2], lineParts[3], lineParts[4], lineParts[5]))
        elif N==7:
            trg.write(ch.format(lineParts[0], lineParts[1], lineParts[2], lineParts[3], lineParts[4], lineParts[5], lineParts[6]))
        elif N==8:
            trg.write(ch.format(lineParts[0], lineParts[1], lineParts[2], lineParts[3], lineParts[4], lineParts[5], lineParts[6], lineParts[7]))
        elif N==9:
            trg.write(ch.format(lineParts[0], lineParts[1], lineParts[2], lineParts[3], lineParts[4], lineParts[5], lineParts[6], lineParts[7], lineParts[8]))
        elif N==10:
            trg.write(ch.format(lineParts[0], lineParts[1], lineParts[2], lineParts[3], lineParts[4], lineParts[5], lineParts[6], lineParts[7], lineParts[8], lineParts[9]))
        elif N==11:
            trg.write(ch.format(lineParts[0], lineParts[1], lineParts[2], lineParts[3], lineParts[4], lineParts[5], lineParts[6], lineParts[7], lineParts[8], lineParts[9], lineParts[10]))
        elif N==12:
            trg.write(ch.format(lineParts[0], lineParts[1], lineParts[2], lineParts[3], lineParts[4], lineParts[5], lineParts[6], lineParts[7], lineParts[8], lineParts[9], lineParts[10], lineParts[11]))
        elif N==13:
            trg.write(ch.format(lineParts[0], lineParts[1], lineParts[2], lineParts[3], lineParts[4], lineParts[5], lineParts[6], lineParts[7], lineParts[8], lineParts[9], lineParts[10], lineParts[11], lineParts[12]))
        elif N==14:
            trg.write(ch.format(lineParts[0], lineParts[1], lineParts[2], lineParts[3], lineParts[4], lineParts[5], lineParts[6], lineParts[7], lineParts[8], lineParts[9], lineParts[10], lineParts[11], lineParts[12], lineParts[13]))
        elif N==15:
            trg.write(ch.format(lineParts[0], lineParts[1], lineParts[2], lineParts[3], lineParts[4], lineParts[5], lineParts[6], lineParts[7], lineParts[8], lineParts[9], lineParts[10], lineParts[11], lineParts[12], lineParts[13], lineParts[14]))
        
        trg.write('\n')

    src.close()
    trg.close()
    return

## A function to obtain len(S_MLI_MLI) without the [0.0] synapses
def realSynLen(syn, MLItable):
    Nc_SynapseObj=0 # calculate the number of connections thanks to the BRIAN synapse object
    MLItable_neuronsN=len(MLItable)*len(MLItable[0])
    for i in range(MLItable_neuronsN):
        for j in range(MLItable_neuronsN):
            if syn.w[i,j].tolist()!=[] and syn.w[i,j].tolist()!=[0.0]:
                Nc_SynapseObj+=1
    return Nc_SynapseObj

if __name__ == '__main__':
    englishTranslatorMLI('False_MLI_table', 'False_MLI_connectivity_english')
    englishTranslatorMLI('MLI_table', 'MLI_connectivity_english')
    



